# RFL Null Block Driver Benchmark Reproduction

This repository aims to **reproduce the performance results in Figure 9** from the paper:

> **An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise**  
> Hongyu Li, Liwei Guo, Yexuan Yang, Shangguang Wang, and Mengwei Xu  
> *USENIX ATC 2024*  
> [Paper link](https://www.usenix.org/conference/atc24/presentation/li-hongyu)

We focus specifically on benchmarking **Rust vs C implementations** of the `null_blk` driver using `fio`.

---

### 1. ðŸ“ Project Structure

â”œâ”€â”€ run_fio_grid.sh
â”œâ”€â”€ results_none
â”‚   â”œâ”€â”€ rand_read
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs2.json
â”‚   â”‚   â”œâ”€â”€ rust_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs2.json
â”‚   â”œâ”€â”€ rand_write
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs1.json
â”‚   â”œâ”€â”€ seq_read
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs1.json
â”‚   â””â”€â”€ seq_write
â”‚       â”œâ”€â”€ c_bs4k_jobs1.json
â”‚       â””â”€â”€ rust_bs4k_jobs1.json
â”œâ”€â”€ results_mq
â”‚   â”œâ”€â”€ rand_read
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs1.json
â”‚   â”œâ”€â”€ rand_write
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs1.json
â”‚   â”œâ”€â”€ seq_read
â”‚   â”‚   â”œâ”€â”€ c_bs4k_jobs1.json
â”‚   â”‚   â””â”€â”€ rust_bs4k_jobs1.json
â”‚   â””â”€â”€ seq_write
â”‚       â”œâ”€â”€ c_bs4k_jobs1.json
â”‚       â””â”€â”€ rust_bs4k_jobs1.json
â””â”€â”€ README.md

- Results files are in the form of {rust/c}_bs{4/8/16/32/64/128}k_jobs{1/2/3/4}.json => each file is a cell in figure 9

## Setup Instructions 

### 2. Enable Null Block and Rust Support

# a) For now, I have only try to replicate the results on the current official RUST-for-linux repo on github (https://github.com/Rust-for-Linux/linux) on branch rust-next

- This is reproduce on my local deskstop via Virtual Box on a clone repository

# b) Configure the kernel
- Initially, when I try to run 'make menuconfig' and try to reboot the kernel with rust support for testing null block device, I did not find the corresponding option. By looking through this blog (), I modify the Kconfig file by commenting out the other options leaving only HAVE_RUST AND RUST_IS_AVAILABLE for config RUST. 

- Enable Rust support under General Setup
- Enable NUll test block driver under Device Drivers -> Block Devices
- Enable RUST null block device testing  

- Also resolve required packages and update rustc version for running make LLVM=1 menuconfig

# c) Build and install

- After I config the kernel, I run this following commands:

- make -j$(nproc) LLVM=1
- sudo make modules_install
- sudo make install
- sudo update-grub
- sudo reboot

- This steps I believe will try to reboot your machine using the newly configured kernel you just modified

# d) After reboot, confirm kernel
- By running uname -r, we should see something new like the new version with dirty suffix at the end

- Double check with ls /dev/nullb*

=> MAKE SURE there are 2 corresponding null block devices C_DEV = /dev/nullb0 and RUST_DEV = /dev/nullb1 


# e) running scripts:
- I have written a small bash scripts run_fio_grid.sh that will try to run the research paper and generate the datas into 2 subfolders (results_none and results_mq) according to the project structure.

- After this, confirmming if the datas is fully generated by running python check.py in the same directory as the 2 newly created folders of datas (make sure to double check the root path in check.py)

- running draw.py at the end will give you a pdf version of the figure 9

### 3) Results 

- I extract the bw field (bandwidth in KiB/s) from the "read" or "write" section in each JSON file generated by fio, depending on the access pattern. This value is converted to MiB/s and used to calculate the performance gain of Rust over C as:

((Bandwidth<sub>Rust</sub> - Bandwidth<sub>C</sub>) / Bandwidth<sub>C</sub>) Ã— 100.

- By looking at the figure 9 after I generate using the reserach paper template code, I notice there's is little to no significant difference between Rust and C implementation, I suspect that this is some of the reasons for this:

---

### Reason 1: Incorrect Kernel Version (Missing `rnull-v6.12-rc2`)
- The original paper used a **rebased kernel**: `rnull-v6.12-rc2`, which merges Linux v6.12-rc2 with Rust driver patches.
- My experiments used the `rust-next` branch directly from the [Rust-for-Linux repository](https://github.com/Rust-for-Linux/linux).

---

### Reason 2: Limited Hardware Resources and Virtualization Overhead
- The original setup used high-end hardware: AMD Ryzen 5 7600, DDR5 RAM, Samsung 990 Pro NVMe SSD.
- My benchmarks were conducted inside a **VirtualBox VM**, which could also contribute a factor in the results

---

### Reason 3: Limited Sample Size and No Confidence Intervals
- The paper averaged **40 samples per configuration** and reported **t-distribution confidence intervals**.
- I used a **single run per configuration** with `--runtime=30`, which could lead to not an ideal solution

---

### ðŸ§ª Reason 5: rnull.ko Compilation or Usage May Be Incorrect
- I may configure the kernel to be not the exact same kernel configuration as the research paper mentions

---





